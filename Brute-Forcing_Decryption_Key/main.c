//
// Created by j4ck on 1/26/24.
//
#include <stdio.h>
#include <windows.h>
#include <time.h>

BOOL GenerateProtectedKey(IN BYTE bHintByte, IN DWORD dwKeySize, OUT PBYTE* ppProtectedKey) {

    srand(time(NULL));

    BYTE b =    (rand() % 0xFF) + 0x01; // The key of the key used for xor each byte

    PBYTE pBuffer = NULL;

    PBYTE pProtectedKey = NULL;

    pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwKeySize);

    pProtectedKey = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwKeySize);


    srand(time(NULL) * 2); // Seed random number generator

    pBuffer[0] = bHintByte;
    for (int i=1; i<=dwKeySize; i++) {
        pBuffer[i] = (BYTE)rand();
    }

    for (int i=0; i<=dwKeySize; i++) {
        pProtectedKey[i] = (BYTE)((pBuffer[i] + i) ^ b);
    }

    *ppProtectedKey = pProtectedKey;
}


BYTE BruteForceDecryption(IN BYTE HintByte, IN SIZE_T sKey, IN PBYTE pProtectedKey, OUT PBYTE* ppRealKey) {

    BYTE      b         = 0;
    PBYTE     pRealKey  = (PBYTE)malloc(sKey);

    if (!pRealKey)
        return 0;

    while (1){

        // Using the hint byte, if this is equal, then we found the 'b' value needed to decrypt the key
        if (((pProtectedKey[0] ^ b) - 0) == HintByte)
            break;
            // else, increment 'b' and try again
        else
            b++;
    }

    // The reverse algorithm of the xor encryption, since 'b' now is known
    for (int i = 0; i < sKey; i++){
        pRealKey[i] = (BYTE)((pProtectedKey[i] ^ b) - i);
    }

    // Saving the decrypted key by pointer
    *ppRealKey = pRealKey;

    return b;
}



int wmain() {
    PBYTE pProtectedKey = NULL;
    PBYTE pDecryptedKey = NULL;

    BYTE secretByte = 0;

    GenerateProtectedKey(0x01, 6, &pProtectedKey);

    secretByte = BruteForceDecryption(0x01, 6, pProtectedKey, &pDecryptedKey);
    if (secretByte == 0) {
        wprintf(L"Failed to Decrypt\n");
        return -1;
    }

    wprintf(L"DecryptedKey %p \n", pDecryptedKey);

    getchar();
    return 0;
}