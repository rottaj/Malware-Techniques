//
// Created by j4ck on 2/24/24.
//
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <winternl.h>

wchar_t* ntdll = L"NTDLL.DLL";
wchar_t* ntdllFullPath = L"C:\\Windows\\System32\\ntdll.dll";

/*
 * NOT USING THIS. IT's HERE AS AN EXAMPLE
 * Using ReadFile WinAPI (1024 offset, triggers callback)
 */
BOOL ReadNtdllFromDiskReadFile() {
    HANDLE hFile = NULL;
    hFile = CreateFileW(ntdllFullPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        wprintf(L"CreateFileW Failed %d\n", GetLastError());
        return FALSE;
    }
    DWORD dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE) {
        wprintf(L"GetFileSize Failed %d\n", GetLastError());
        return FALSE;
    }
    LPVOID lpBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize);
    if (lpBuffer == NULL) {
        wprintf(L"HeapAlloc Failed %d\n", GetLastError());
        return FALSE;
    }
    DWORD dwBytesWritten = 0;
    if (!ReadFile(hFile, lpBuffer, dwFileSize, &dwBytesWritten, NULL)) {
        wprintf(L"ReadFile Failed %d\n", GetLastError());
        return FALSE;
    }

    wprintf(L"NTDLL %p\n", lpBuffer);

    UINT_PTR pBaseAddress = (UINT_PTR)lpBuffer;
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBaseAddress;

    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(pBaseAddress + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        wprintf(L"NT SIGNATURE FAILURE");
        return FALSE;
    }

    PIMAGE_OPTIONAL_HEADER pOptionalHeader = (PIMAGE_OPTIONAL_HEADER)(&pNtHeaders->OptionalHeader);
    wprintf(L".text: %p\n.text size: %d\n", pBaseAddress + pOptionalHeader->BaseOfCode, pOptionalHeader->SizeOfCode);

    // Cleanup
}

/*
 * CreateFileMappingA and MapViewOfFile 4096 offset. SEC_IMAGE_NO_EXECUTE does not trigger callback
 */
PVOID MapNtdllFromDisk() {
    HANDLE hFile = NULL;
    HANDLE hMappingFile = NULL;

    hFile = CreateFileW(ntdllFullPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        wprintf(L"CreateFileW Failed %d\n", GetLastError());
        return FALSE;
    }
    DWORD dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE) {
        wprintf(L"GetFileSize Failed %d\n", GetLastError());
        return FALSE;
    }
    // Use SEC_IMAGE_NO_EXECUTE (needed for offset & not to trigger callback)
    hMappingFile = CreateFileMappingW(hFile, NULL, PAGE_READONLY | SEC_IMAGE_NO_EXECUTE, 0, 0, (LPCWSTR)NULL);
    if (!hMappingFile) {
        wprintf(L"CreateFileMappingW Failed: %d\n", GetLastError());
        return FALSE;
    }

    LPVOID lpBuffer = MapViewOfFile(hMappingFile, FILE_MAP_READ | FILE_MAP_COPY, 0, 0, 0);
    if (lpBuffer == NULL) {
        wprintf(L"MapViewOfFile Failed: %d\n", GetLastError());
        return FALSE;
    }

    return lpBuffer;
}

PVOID FetchLocalNtdllAddress() {
    PPEB pPeb = (PPEB)__readgsqword(0x60);
    PLDR_DATA_TABLE_ENTRY pLdr = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPeb->Ldr->InMemoryOrderModuleList.Flink->Flink - 0x10);
    return pLdr->DllBase;
}

BOOL FetchLocalTextSectionNtdll(IN PVOID pBaseAddress, OUT DWORD* pdwSizeOfText, OUT PVOID* ppAddressOfText) {
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBaseAddress;
    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(pBaseAddress + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        return FALSE;
    }
    PIMAGE_OPTIONAL_HEADER pOptionalHeader = (PIMAGE_OPTIONAL_HEADER)&pNtHeaders->OptionalHeader;

    *pdwSizeOfText = pOptionalHeader->SizeOfCode;
    *ppAddressOfText = (pBaseAddress + pOptionalHeader->BaseOfCode);

    return TRUE;
}


BOOL SwapNtdllTextSections(IN PVOID pLocalNtdll, IN PVOID pUnhookedNtdll, IN DWORD dwSizeOfText) {
    wprintf(L"Local NTDLL: %p\nUnhooked NTDLL: %p\nSize of Text: %d\n", pLocalNtdll, pUnhookedNtdll, dwSizeOfText);
    // Update Local NTDLL Memory Permissions to RWX Access (Currently only RX)
    DWORD dwOldPermissions = 0;
    if (!VirtualProtect(pLocalNtdll, dwSizeOfText, PAGE_EXECUTE_WRITECOPY, &dwOldPermissions)) {
        wprintf(L"VirtualProtect Failed %d", GetLastError());
        return FALSE;
    }
    getchar();
    // Copy Memory from Unhooked to Local
    memcpy(pLocalNtdll, pUnhookedNtdll, dwSizeOfText);

    if (!VirtualProtect(pLocalNtdll, dwSizeOfText, dwOldPermissions, NULL)) {
        wprintf(L"VirtualProtect Failed %d", GetLastError());
        return FALSE;
    }
    return TRUE;
}



int wmain() {

    HANDLE hModule = NULL;
    UINT_PTR pBaseAddress = 0;
    //ReadNtdllFromDiskReadFile();



    // Fetch & Handle LOCAL NTDLL
    DWORD dwSizeOfText = 0;
    PVOID pAddressOfText = NULL;
    PVOID pNtdllBaseAddress = FetchLocalNtdllAddress();
    if (!FetchLocalTextSectionNtdll(pNtdllBaseAddress, &dwSizeOfText, &pAddressOfText)) {
        wprintf(L"FetchLocalTextSectionNtdll Failed\n");
        return -1;
    }

    // Fetch & Handle DISK NTDLL
    ULONG_PTR pUnhookedTxtNtdll = (ULONG_PTR)(MapNtdllFromDisk()) + 4096;

    SwapNtdllTextSections(pAddressOfText, (PVOID)pUnhookedTxtNtdll, dwSizeOfText);
    getchar();


    return 0;
}